[{"title":"超好吃的鸡蛋煎饼果子！！","url":"/2021/08/13/EggStuffedPancake/","content":"加花生香菜鸡蛋热乎乎的煎饼果子（小店还有火腿、豆皮、鸡柳、）怎么养成呐？来跟着我一起搞起来吧。\n\n请跟我这样做哈准备食材·面糊 300g·生菜 若干·火腿肠 n·香菜 适量·酱油 一勺·花生 适量·鸡蛋 俩（一个不够吃吧hhh）准备好啦，开始做喽。\n步骤1、 和面粉（干了就加水，尽量稠一点）。\n2、 锅烧热（别整冒烟了），俩勺面糊快速摊开在平底锅，搞成薄饼（最好不要放油哦，要是粘锅的话，抹薄薄一层就可）。\n3、 烙好一面把饼翻过来，打上我们的两个蛋，等鸡蛋稍稍凝固好了再翻过来（这时可以在这边涂上喜欢的酱呐）。\n4、 煎好后，将准备好的花生、香菜等等等都放到里面。\n5、 一边对折，卷的好好的（别给整掉了hhh）\n6、 大功告成！\n做煎饼果子的N种方式制作步骤回顾:从上面的图解中我们可以看到，流程是这样的：\n1、面粉 + 水 -&gt; 面浆；面浆 + 烘焙 -&gt; 煎饼2、煎饼 + 鸡蛋 + 烘焙 -&gt; 鸡蛋煎饼3、鸡蛋煎饼 + 生菜 -&gt; 带有生菜的鸡蛋煎饼4、带有生菜的鸡蛋煎饼 + 火腿肠 -&gt; 带有生菜和火腿肠的鸡蛋煎饼5、带有生菜和火腿肠的鸡蛋煎饼 + 卷曲 + 切断 -&gt; 煎饼果子\n我们对上面的步骤进行化简：\n1、面粉 -&gt; 煎饼2、煎饼 + 鸡蛋 -&gt; 鸡蛋煎饼3、鸡蛋煎饼 + 生菜 + 火腿肠 -&gt; 煎饼果子\n我们对上面的步骤继续化简：\n面粉 -&gt; 煎饼 -&gt; 鸡蛋 -&gt; 鸡蛋煎饼 -&gt; 生菜 -&gt; 火腿肠 -&gt; 煎饼果子\n下面让我们使用代码先来模拟下，验证怎么样才可以高效的做出煎饼果子吧。\nN种方式原文链接\n","categories":["代码？"],"tags":["生活"]},{"title":"Hello World","url":"/2021/08/12/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"浅谈广播机制","url":"/2021/08/13/%E6%B5%85%E8%B0%88%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/","content":"我们在平时的学习和日常生活中都接触过广播，通常用来发送一些重要的通知，类似的广播机制其实在计算机领域也得到了广泛的应用，在经过大致的学习后，进行小小的概括总结。\n简介广播主要分为两种类型：标准广播和有序广播。\n标准广播标准广播是一种完全异步执行的广播，即在广播发出之后，所有的广播接收器几乎都会在同一时间接收到这条广播。\n特点：1、不存在先后顺序。  2、效率较高。  3、无法被截断。\n有序广播有序广播是一种同步执行的广播，即在广播发出之后，同一时间只会有一个广播接收器能收到这条广播，只有当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。\n特点：1、有先后顺序。  2、前面的广播接收器可以截断正在传递的广播。\n接收系统广播系统广播：比如开机完成后，电量不足是发出的广播等等，想要接收到这些广播，则需要使用广播接收器。\n广播的注册方式一般有两种：动态注册（在代码中注册）和静态注册（在AndroidMainifest.xml中注册）。\n动态注册监听网络变化优点：可以对广播实现自由地控制注册与取消\n如何创建广播接收器？————新建一个类，让其继承自BroadcastReceiver，并重写父类的onReceive（）方法即可。\n注：1、动态注册的广播接收器必须要取消注册，我们可以在onDestroy（）方法中通过调用unregisterReceiver（）方法来实现2、若程序需要进行一些敏感操作，必须在配置文件中声明权限！如若访问系统网络状态，则需在AndroidMainfest.xml文件加入\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;\n\n静态注册实现开机启动优点：可以实现在程序未启动的情况下就接收到广播。\n使用Android Studio提供的快捷方式来创建一个广播接收器。\n注：1、静态的广播接收器一定要在AndroidMainfest.xml文件中注册才可以（用快捷方式创建时已自动完成注册）。2、声明权限，监听系统开机广播，需要加入\n&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;\n3、需要在标签里添加相应的action。此处添加\n&lt;intent-filter android:priority=&quot;100&quot;&gt;   &lt;action android:name=&quot;android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;&quot;/&gt;&lt;/intent-filter&gt;\n4、不要在onReceive（）方法中添加过多的逻辑或者进行任何的耗时操作，因为在广播接收器中是不允许开启线程的。\n发送自定义广播发送标准广播1、定义一个广播接收器来准备进行接受此广播。2、在AndroidMainfest.xml中对广播接收器进行修改。3、在activity_main.xml布局文件中添加button作为广播触发点。4、在MainActivity中给按钮的点击事件加入发送自定义广播的逻辑（通过Intent来进行广播传递则可传递一些数据给广播接收器）。\n发送有序广播1、新建一个项目，并新建一个另一个广播接收器（用于接收上面的自定义广播），在AndroidMainfest.xml文件中对其进行修改。2、回到前一个项目，修改MainActivity中sendBroadcast（）方法为sendOrderdBroadcast（）方法。3、在AndroidMainfest.xml文件中 通过android：priority属性给广播接收器设置优先级（高的先接受广播）。4、在onReceive（）方法中调用abortBroadcast（）方法则可将本条广播截断，则之后的广播接收器无法收到此广播。\n使用本地广播优点：安全高效，避免携带关键性数据的广播被其他应用程序截取或其他应用程序向我们不断发送垃圾广播。\n方法：使用LocalBroadcastManager对广播进行管理，并提供发送广播和注册广播接收器的方法。\n注：本地广播无法通过静态注册的方式来接收。\n","categories":["Android"]},{"title":"。。？","url":"/2021/08/13/%EF%BC%9F%EF%BC%9F%EF%BC%9F/","content":"致自己部署Hexo踩过的坑 \nnode版本太高(node:26356) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency(Use `node --trace-warnings ...` to show where the warning was created)(node:26356) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency(node:26356) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency(node:26356) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency(node:26356) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency(node:26356) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency\n\n解决办法：切换成低版本的node来安装Hexo\n一、先清空本地安装的node.js版本（彻底删除）\n二、安装nvm管理工具1、从官网下载安装包。\n2、将下载下的压缩包进行解压。\n3、进行nvm安装，安装完成后，检验是否安装成功，输入命令nvm v查看，若出现版本号，则安装成功。\n三、安装node.js版本1、输入命令nvm list available查看可用的版本号。\n2、输入命令nvm install node版本号(例如：nvm install 14.17.5)即可安装对应版本与对应的npm版本，安装完成后，分别输入命令node -v和npm -v检验node.js与对应的npm是否安装成功，若出现版本号，则安装成功。\n3、输入命令nvm list可查看所安装的所有node.js版本号以及当前所选的运行版本。\n4、输入命令nvm use node版本号（例如：nvm use 14.17.5）即可选择本地所使用的node.js版本，该命令可根据自己的需要，随意切换node.js版本运行。\n5、若想删除某node.js版本的话，输入命令nvm uninstall node版本号（例如：nvm uninstall 12.22.04）即可删除对应版本\n缺少冒号？✘————空格！err: YAMLException: can not read an implicit mapping pair; a colon is missed (42:47)\n\n原因：格式出错了！冒号后没有空格导致没有成功映射。\n解决办法：在对应的冒号后加空格（冒号后一定要加！）。\n使用Gitalk插件出现未找到相关的issues进行评论原因：未给文章评论初始化，只需要登录 GitHub 账户即可（就这？）。\n缺少空格err: YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 5, column 1:\n\n原因：报错信息是提示hexo的yml配置文件，冒号后面少了空格。\n解决方案：到提示行将对应的空格补上即可。\nbash: hexo: command not found 报错背景：好几天没动过Hexo博客，今天准备更新的时候突然报错bash: hexo: command not found，搞的本人一脸懵，原先不是好好的，想想可能是处理node版本太高更新或删掉什么东西了。\n解决办法（查的）：首先检查node.js和npm是否正常，依次输入命令node -v和npm -v看看是否有相关的版本信息\n出现了版本信息就证明 node.js 和 npm 是没有问题的，那么极有可能是环境变量的配置问题了。\n我们找到本地博客目录下node_modules文件夹，将 node_modules 下的 .bin 文件路径复制下来添加到环境变量中。\n环境变量配好之后，重新打开git执行hexo命令，即可运行，如果此时仍然无法执行 hexo 命令，运行命令 npm install hexo-cli -g ，重新安装 hexo。\n如何获取图片的url地址？方法链接\n","categories":["报错"]}]